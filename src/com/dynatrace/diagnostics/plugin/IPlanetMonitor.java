
/**
 * This template file was generated by dynaTrace client.
 * The dynaTrace community portal can be found here: http://community.compuwareapm.com/
 * For information how to publish a plugin please visit http://community.compuwareapm.com/plugins/contribute/
 **/

package com.dynatrace.diagnostics.plugin;

import java.io.StringWriter;
import java.net.ConnectException;
import java.security.cert.X509Certificate;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathFactory;

import org.w3c.dom.Document;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import com.dynatrace.diagnostics.pdk.Monitor;
import com.dynatrace.diagnostics.pdk.MonitorEnvironment;
import com.dynatrace.diagnostics.pdk.MonitorMeasure;
import com.dynatrace.diagnostics.pdk.Plugin;
import com.dynatrace.diagnostics.pdk.Status;

public class IPlanetMonitor implements Monitor {

	public static final Logger log = Logger.getLogger(IPlanetMonitor.class.getName());

	private RangeGroup rangeGroup;

	private String waitMethod;

	/**
	 * The restAPI is the variable allowing access to the data displayed in
	 * dashboards
	 */
	private ServerRestAPI restAPI;

	HostnameVerifier defaultVerifier = HttpsURLConnection.getDefaultHostnameVerifier();
	XPath xpath = XPathFactory.newInstance().newXPath();
	private Document doc;

	/**
	 * Initializes the Plugin. This method is called in the following cases:
	 * <ul>
	 * <li>before <tt>execute</tt> is called the first time for this scheduled
	 * Plugin</li>
	 * <li>before the next <tt>execute</tt> if <tt>teardown</tt> was called
	 * after the last execution</li>
	 * </ul>
	 * <p>
	 * If the returned status is <tt>null</tt> or the status code is a
	 * non-success code then {@link Plugin#teardown() teardown()} will be called
	 * next.
	 * <p>
	 * Resources like sockets or files can be opened in this method.
	 * 
	 * @param env
	 *            the configured <tt>MonitorEnvironment</tt> for this Plugin;
	 *            contains subscribed measures, but <b>measurements will be
	 *            discarded</b>
	 * @see Plugin#teardown()
	 * @return a <tt>Status</tt> object that describes the result of the method
	 *         call
	 */

	@Override
	public Status setup(MonitorEnvironment env) throws Exception {
		log.info("calling setup");
		Status status = new Status(Status.StatusCode.Success);
		// check plugin environment configuration parameter values
		if (env != null && env.getHost() == null) {
			status.setStatusCode(Status.StatusCode.ErrorInternalConfigurationProblem);
			status.setShortMessage("Environment was not properly initialized. env.host must not be null.");
			status.setMessage("Environment was not properly initialized. env.host must not be null.");
			Exception e = new IllegalArgumentException(
					"Environment was not properly initialized. env.host must not be null.");
			status.setException(e);
			log.log(Level.SEVERE, status.getMessage(), e);
			return status;
		}
		
		if (env != null){
			restAPI = new ServerRestAPI(env.getConfigString("dtServer"), env.getConfigString("username"),
				env.getConfigPassword("password"));
			log.info("Created ServerRestAPI");
			rangeGroup = new RangeGroup(env.getConfigString("buckets").split(","));
			waitMethod = env.getConfigString("SubtractMethod");
		}else{
			restAPI = new ServerRestAPI("localhost", "admin", "admin");
			rangeGroup = new RangeGroup("1000,2000,3000,4000,5000,10000,15000".split(","));
			waitMethod = "org.eclipse.jface.window.Window.runEventLoop(org.eclipse.swt.widgets.Shell loopShell)";
		}
		
		log.info("finished setup");
		return status;
	}

	@Override
	public Status execute(MonitorEnvironment env) throws Exception {
		log.info("calling execute");
		Status status = new Status();

		try {

			TrustSSL.trustAllCerts();
			// Return the XML document
			if (env != null){
				log.fine("getting dashboard " + env.getConfigString("dashboardName"));
				doc = restAPI.getDashboard(env.getConfigString("dashboardName"));
			}else{
				log.fine("getting dashboard Baloise3");
				doc = restAPI.getDashboard("Baloise3");
			}
			log.finer(getString(doc));

			NodeList dashlets = doc.getElementsByTagName("purepathsdashlet");

			if (dashlets != null) {
				int length = dashlets.getLength();
				for (int i = 0; i < length; i++) {
					calculateAllDashlets(env, dashlets.item(i));
				}
			}
			
			HttpsURLConnection.setDefaultHostnameVerifier(defaultVerifier);
		} catch (ConnectException ce) {
			status.setException(ce);
			status.setStatusCode(Status.StatusCode.PartialSuccess);
			status.setShortMessage(ce == null ? "" : ce.getClass().getSimpleName());
			log.log(Level.SEVERE, status.getMessage(), ce);
			ce.printStackTrace();
		} catch (Exception ioe) {
			status.setException(ioe);
			status.setStatusCode(Status.StatusCode.ErrorTargetServiceExecutionFailed);
			status.setShortMessage(ioe == null ? "" : ioe.getClass().getSimpleName());
			log.log(Level.SEVERE, status.getMessage(), ioe);
			ioe.printStackTrace();
		}

		log.info("finished execute");
		return status;
	}

	private void calculateAllDashlets(MonitorEnvironment env, Node dashlet) {
		rangeGroup.resetGroups();
		String dashletName = dashlet.getAttributes().getNamedItem("name").getNodeValue();
		log.fine("Calculating " + dashletName);
		
		NodeList dashletChildren = dashlet.getChildNodes();
		for (int i = 0; i < dashletChildren.getLength(); i++) {
			if (dashletChildren.item(i).getNodeName().equals("purepaths")){// Get all measures
				
				NodeList purePathNodes = dashletChildren.item(i).getChildNodes(); 
				int nodeLength = purePathNodes.getLength();
				double sumNetDiff = 0;
				double countNetDiff = 0;
				for (int nodeIndex = 0; nodeIndex < nodeLength; nodeIndex++) {
					Node purePathNode = purePathNodes.item(nodeIndex);
					if (purePathNode.getNodeName().equals("purepath")){
						log.finer("Found PurePath " + purePathNode.getAttributes().getNamedItem("name").getNodeValue());
						double netDiff = 0;
						double purePathResponseTime = Double.parseDouble(purePathNode.getAttributes().getNamedItem("response_time").getNodeValue());
						double methodWaitTime = getMethodWaitTime(purePathNode);
						
						netDiff = Math.max(0, purePathResponseTime - methodWaitTime);
						log.finer("purePathResponseTime " + purePathResponseTime);
						log.finer("methodWaitTime " + methodWaitTime);
						log.finer("netDiff " + netDiff);
						
						rangeGroup.addToGroup(netDiff);
						sumNetDiff += netDiff;
						countNetDiff++;
					}
				}
				if (countNetDiff > 0){
					double finalNetDiff = sumNetDiff / countNetDiff;
					if (env != null){
						MonitorMeasure monitorMeasure = env.getMonitorMeasures("NetDiff", "netDiff").iterator().next();
						MonitorMeasure dynamicMeasure = env.createDynamicMeasure(monitorMeasure, "NetDiff",
								dashletName);
						dynamicMeasure.setValue(finalNetDiff);
						log.finer("Result: NetDiff-" + dashletName + " - " + finalNetDiff);
					}else{
						System.out.println("NetDiff-" + dashletName + " - " + finalNetDiff);
					}
				}
			}
		}
		
		if (env == null){
			rangeGroup.sendMeasures(null, null, dashletName);
		}else{
			rangeGroup.sendMeasures(env, env.getMonitorMeasures("NetDiff", "Bucket").iterator().next(), dashletName);
		}
		log.fine("Finished calculating " + dashletName);
	}

	private double getMethodWaitTime(Node node) {
		double returnValue = 0;
		NodeList nodeChildren = node.getChildNodes();
		for (int i = 0; i < nodeChildren.getLength(); i++) {
			Node currentNode = nodeChildren.item(i);
			if (currentNode.getNodeName().equals("node")){
				NamedNodeMap attributes = currentNode.getAttributes();
				Node className = attributes.getNamedItem("class");
				Node methodName = attributes.getNamedItem("method");
//				Node breakdown = attributes.getNamedItem("breakdown");
				Node totaltime = attributes.getNamedItem("totaltime");
				log.finest("className " + className);
				log.finest("methodName " + methodName);
				log.finest("totaltime " + totaltime);
				if (className!= null && methodName != null && totaltime != null){
					if ((className.getNodeValue() + "." + methodName.getNodeValue()).equals(waitMethod)){
//						double waitTime = 0;
//						String[] breakdownParts = breakdown.getNodeValue().split(", ");
//						for (String breakdownPart : breakdownParts) {
//							if (breakdownPart.contains("Wait Total: ")){
//								waitTime = Double.parseDouble(breakdownPart.substring("Wait Total: ".length(), breakdownPart.length() - " ms".length()).replace(",", ""));
//							}
//						}
						log.finer("adding to wait time " + Double.parseDouble(totaltime.getNodeValue()));
						returnValue += Double.parseDouble(totaltime.getNodeValue());
					}
				}
				returnValue += getMethodWaitTime(currentNode);
			}
		}
		return returnValue;
	}
	
	private String getString(Document doc) throws TransformerException{ 
		DOMSource domSource = new DOMSource(doc);
		StringWriter writer = new StringWriter();
		StreamResult result = new StreamResult(writer);
		TransformerFactory tf = TransformerFactory.newInstance();
		Transformer transformer = tf.newTransformer();
		transformer.transform(domSource, result);
		return writer.toString();
	}

	/**
	 * Shuts the Plugin down and frees resources. This method is called in the
	 * following cases:
	 * <ul>
	 * <li>the <tt>setup</tt> method failed</li>
	 * <li>the Plugin configuration has changed</li>
	 * <li>the execution duration of the Plugin exceeded the schedule
	 * timeout</li>
	 * <li>the schedule associated with this Plugin was removed</li>
	 * </ul>
	 *
	 * <p>
	 * The Plugin methods <tt>setup</tt>, <tt>execute</tt> and <tt>teardown</tt>
	 * are called on different threads, but they are called sequentially. This
	 * means that the execution of these methods does not overlap, they are
	 * executed one after the other.
	 *
	 * <p>
	 * Examples:
	 * <ul>
	 * <li><tt>setup</tt> (failed) -&gt; <tt>teardown</tt></li>
	 * <li><tt>execute</tt> starts, configuration changes, <tt>execute</tt> ends
	 * -&gt; <tt>teardown</tt><br>
	 * on next schedule interval: <tt>setup</tt> -&gt; <tt>execute</tt> ...</li>
	 * <li><tt>execute</tt> starts, execution duration timeout, <tt>execute</tt>
	 * stops -&gt; <tt>teardown</tt></li>
	 * <li><tt>execute</tt> starts, <tt>execute</tt> ends, schedule is removed
	 * -&gt; <tt>teardown</tt></li>
	 * </ul>
	 * Failed means that either an unhandled exception is thrown or the status
	 * returned by the method contains a non-success code.
	 *
	 *
	 * <p>
	 * All by the Plugin allocated resources should be freed in this method.
	 * Examples are opened sockets or files.
	 *
	 * @see Monitor#setup(MonitorEnvironment)
	 */
	@Override
	public void teardown(MonitorEnvironment env) throws Exception {
		log.info("calling teardown");
		HttpsURLConnection.setDefaultHostnameVerifier(defaultVerifier);
		log.info("finished teardown");
	}
}

class TrustSSL {

	public static void trustAllCerts() throws Exception {
		// Create a trust manager that does not validate certificate chains
		TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {
			public java.security.cert.X509Certificate[] getAcceptedIssuers() {
				return null;
			}

			public void checkClientTrusted(X509Certificate[] certs, String authType) {
			}

			public void checkServerTrusted(X509Certificate[] certs, String authType) {
			}
		} };
		// Install the all-trusting trust manager
		final SSLContext sc = SSLContext.getInstance("SSL");
		sc.init(null, trustAllCerts, new java.security.SecureRandom());
		HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
		// Create all-trusting host name verifier
		HostnameVerifier allHostsValid = new HostnameVerifier() {
			public boolean verify(String hostname, SSLSession session) {
				return true;
			}
		};

		// Install the all-trusting host verifier
		HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid);

	}
}
